<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>ギリシャ文字暗号化・復号ツール（新仕様）</title>
<style>
body {
    font-family: Arial, sans-serif;
    margin: 20px;
    background: #f8f9fa;
}
textarea {
    width: 100%;
    height: 100px;
    margin-bottom: 10px;
    font-size: 16px;
}
button {
    padding: 8px 16px;
    margin: 5px;
    font-size: 16px;
}
#output {
    background: #fff;
    border: 1px solid #ccc;
    padding: 10px;
    min-height: 80px;
    font-size: 16px;
    white-space: pre-wrap;
}
.footer-btn {
    display: block;
    width: fit-content;
    margin-top: 30px;
    padding: 8px 16px;
    background: #007bff;
    color: white;
    text-decoration: none;
    border-radius: 4px;
}
.footer-btn:hover {
    background: #0056b3;
}
</style>
</head>
<body>

<h2>ギリシャ文字暗号化・復号ツール（新仕様）</h2>

<textarea id="inputText" placeholder="ここに文字を入力"></textarea><br>
<button onclick="encryptText()">暗号化</button>
<button onclick="decryptText()">復号</button>
<button onclick="clearText()">クリア</button>

<h3>結果</h3>
<div id="output"></div>
<button onclick="copyResult()">コピー</button>

<a href="https://otsuru2355.github.io/ang0u-fukugou-tool/" class="footer-btn">前回の暗号機</a>

<script>
// === カテゴリ用ギリシャ文字 ===
const catMark = {
    hira: 'α', // ひらがな
    kana: 'β', // カタカナ
    alpha: 'γ', // アルファベット
    symbol: 'δ', // 記号
    greek: 'ε', // ギリシャ文字
    num: 'ζ' // 数字
};

// 2文字目（大小）
const sizeMark = {
    small: 'η', // 小文字
    large: 'θ'  // 大文字
};

// 3文字目（全角半角）
const widthMark = {
    half: 'ι',
    full: 'κ'
};

// 4文字目（清音/濁音/半濁音）
const soundMark = {
    clear: 'λ',
    voiced: 'μ',
    semi: 'ν'
};

// 5〜8文字目（個別コード文字）
const codeChars = ['ξ','ο','π','ρ','σ','τ','υ','φ','χ','ψ','ω'];

// 文字分類用データ
const hira = "ぁあぃいぅうぇえぉおかがきぎくぐけげこごさざしじすずせぜそぞただちぢつづてでとどなにぬねのはばぱひびぴふぶぷへべぺほぼぽまみむめもゃやゅゆょよらりるれろゎわゐゑをんっ";
const kana = "ァアィイゥウェエォオカガキギクグケゲコゴサザシジスズセゼソゾタダチヂツヅテデトドナニヌネノハバパヒビピフブプヘベペホボポマミムメモャヤュユョヨラリルレロヮワヰヱヲンヴッ";
const alphaUpper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
const alphaLower = "abcdefghijklmnopqrstuvwxyz";
const greekUpper = "ΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡΣΤΥΦΧΨΩ";
const greekLower = "αβγδεζηθικλμνξοπρστυφχψω";
const numbers = "0123456789０１２３４５６７８９";

// 記号カテゴリ（全角半角両方）
const symbols = `!"#$%&'()*+,-./:;<=>?@[\\]^_{|}~！＂＃＄％＆＇（）＊＋，－．／：；＜＝＞？＠［￥］］＾＿｛｜｝～
ー、。/\\／＼〜＝=＋+-×✕÷＊*,._＿^:;：；#"'”’＃・･…「」『』【】〔〕〈〉《》〃々—〜…※`;

// 固定変換表
let mapping = {};
let reverseMapping = {};
let counter = 0;

// 個別コード生成（5〜8文字目）
function generateCode(num) {
    let chars = [...codeChars];
    let code = '';
    for (let i = 0; i < 4; i++) {
        let idx = num % chars.length;
        code += chars[idx];
        chars.splice(idx, 1);
        num = Math.floor(num / (chars.length + 1));
    }
    return code;
}

// マッピング作成関数
function addMapping(ch, category, size, width, sound) {
    const code = category + size + width + sound + generateCode(counter++);
    mapping[ch] = code;
    reverseMapping[code] = ch;
}

// 文字判定 & マッピング作成
function buildMappings() {
    const allChars = hira + kana + alphaUpper + alphaLower + greekUpper + greekLower + numbers + symbols;
    for (let ch of allChars) {
        let category, size, width, sound;

        // カテゴリ判定
        if (hira.includes(ch)) category = catMark.hira;
        else if (kana.includes(ch)) category = catMark.kana;
        else if (alphaUpper.includes(ch) || alphaLower.includes(ch)) category = catMark.alpha;
        else if (greekUpper.includes(ch) || greekLower.includes(ch)) category = catMark.greek;
        else if (numbers.includes(ch)) category = catMark.num;
        else if (symbols.includes(ch)) category = catMark.symbol;
        else continue;

        // 大小判定
        if (alphaLower.includes(ch) || greekLower.includes(ch) ||
            "ぁぃぅぇぉゃゅょゎっァィゥェォャュョヮッ".includes(ch)) {
            size = sizeMark.small;
        } else {
            size = sizeMark.large;
        }

        // 全角半角判定
        width = (ch.match(/[ -~]/)) ? widthMark.half : widthMark.full;

        // 音判定（ひらがな・カタカナのみ）
        if ("がぎぐげござじずぜぞだぢづでどばびぶべぼ".includes(ch)) sound = soundMark.voiced;
        else if ("ぱぴぷぺぽ".includes(ch)) sound = soundMark.semi;
        else sound = soundMark.clear;

        addMapping(ch, category, size, width, sound);
    }
}

buildMappings();

// 暗号化
function encryptText() {
    const input = document.getElementById('inputText').value;
    let result = [];
    for (let ch of input) {
        if (mapping[ch]) {
            result.push(mapping[ch]);
        } else {
            result.push(ch);
        }
    }
    document.getElementById('output').textContent = result.join(' ');
}

// 復号
function decryptText() {
    const input = document.getElementById('inputText').value.trim().split(/\s+/);
    let result = '';
    for (let code of input) {
        if (reverseMapping[code]) {
            result += reverseMapping[code];
        } else {
            result += code;
        }
    }
    document.getElementById('output').textContent = result;
}

// コピー
function copyResult() {
    const text = document.getElementById('output').textContent;
    if (!text) {
        alert("コピーする内容がありません。");
        return;
    }
    navigator.clipboard.writeText(text).then(() => {
        alert("コピーしました！");
    }).catch(err => {
        alert("コピーに失敗しました: " + err);
    });
}

// クリア
function clearText() {
    document.getElementById('inputText').value = '';
    document.getElementById('output').textContent = '';
}
</script>

</body>
</html>
